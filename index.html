<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OSRS Crafting Profit Calculator</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; max-width: 800px; margin: auto; }
    h1, h2, h3 { color: #2c3e50; }
    .profit { margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 8px; background: #f9f9f9; }
    .positive { color: green; }
    .negative { color: red; }
    textarea { width: 100%; font-family: monospace; margin-top: 10px; }
    button { margin-top: 10px; padding: 8px 16px; font-size: 16px; }
  </style>
</head>
<body>
  <h1>OSRS Crafting Profit Calculator</h1>
  <button onclick="refreshData()">Refresh Prices</button>
  <div id="results"></div>

  <h2>Custom Recipe</h2>
  <textarea id="custom-recipe" rows="5" placeholder="Example:\n1 Runite ore\n8 Coal\n= 1 Runite bar"></textarea><br>
  <button onclick="addCustomRecipe()">Add Custom Recipe</button>

  <script>
    // Updated cache URLs (your GitHub raw JSON cache)
    const baseCacheUrl = 'https://raw.githubusercontent.com/KeelanRobertson/osrs/main/cache/';
    const mappingUrl = baseCacheUrl + 'mapping.json';
    const latestUrl = baseCacheUrl + 'latest.json';
    const fiveMinUrl = baseCacheUrl + '5m.json';
    const tenMinUrl = baseCacheUrl + '10m.json';
    const thirtyMinUrl = baseCacheUrl + '30m.json';
    const oneHourUrl = baseCacheUrl + '1h.json';

    let itemsById = {};
    let itemsByName = {};

    const recipes = [
      {
        name: "Runite Bar",
        output: { item: "Runite bar", quantity: 1 },
        inputs: [
          { item: "Runite ore", quantity: 1 },
          { item: "Coal", quantity: 8 },
        ]
      },
      {
        name: "Steel Bar",
        output: { item: "Steel bar", quantity: 1 },
        inputs: [
          { item: "Iron ore", quantity: 1 },
          { item: "Coal", quantity: 2 },
        ]
      }
    ];

    async function fetchData() {
      // Fetch all price data from the cache
      const [mapping, latest, fiveMin, tenMin, thirtyMin, oneHour] = await Promise.all([
        fetch(mappingUrl).then(res => res.json()),
        fetch(latestUrl).then(res => res.json()),
        fetch(fiveMinUrl).then(res => res.json()),
        fetch(tenMinUrl).then(res => res.json()),
        fetch(thirtyMinUrl).then(res => res.json()),
        fetch(oneHourUrl).then(res => res.json()),
      ]);

      // Reset data holders
      itemsById = {};
      itemsByName = {};

      // Build items indexed by id and name, merging data for each item
      mapping.forEach(item => {
        const id = item.id;
        itemsById[id] = {
          ...item,
          latest: latest.data[id],
          fiveMin: fiveMin.data[id],
          tenMin: tenMin.data[id],
          thirtyMin: thirtyMin.data[id],
          oneHour: oneHour.data[id]
        };
        itemsByName[item.name.toLowerCase()] = itemsById[id];
      });
    }

    // Gets price for an item by type of pricing
    // type can be 'latest', 'fiveMin', 'tenMin', 'thirtyMin', 'oneHour'
    // priceType: which price to get: default 'high', fallback to 'avgHighPrice' for averages
    function getPrice(itemName, type = 'latest', priceType = 'high') {
      const item = itemsByName[itemName.toLowerCase()];
      if (!item) return 0;

      const data = item[type];
      if (!data) return 0;

      // Some fields use different naming for averages
      if (type === 'latest') {
        return data[priceType] || 0;
      } else {
        // For averages, common keys: avgHighPrice, avgLowPrice
        if (priceType === 'high') return data.avgHighPrice || 0;
        if (priceType === 'low') return data.avgLowPrice || 0;
        return 0;
      }
    }

    function calculateProfit(recipe, priceType = 'latest') {
      const outputPrice = getPrice(recipe.output.item, priceType, 'high') * recipe.output.quantity;

      const inputDetails = recipe.inputs.map(input => {
        const price = getPrice(input.item, priceType, 'high');
        return {
          ...input,
          price,
          total: price * input.quantity
        };
      });

      const inputCost = inputDetails.reduce((sum, i) => sum + i.total, 0);
      const profit = outputPrice - inputCost;

      // Calculate required sell price and required buy prices for inputs
      // The required sell price per output item to achieve the profit:
      const requiredSellPricePerOutput = Math.ceil((inputCost + profit) / recipe.output.quantity);

      // Calculate max buy price for each input to achieve the same profit given the required sell price
      const requiredBuyPrices = inputDetails.map((inputDetail, _, arr) => {
        const otherInputsCost = inputCost - inputDetail.total;
        const needed = (requiredSellPricePerOutput * recipe.output.quantity) - otherInputsCost;
        const maxBuyPrice = Math.floor(needed / inputDetail.quantity);
        return {
          item: inputDetail.item,
          price: maxBuyPrice
        };
      });

      return {
        recipeName: recipe.name,
        outputPrice,
        inputCost,
        profit,
        requiredSellPrice: requiredSellPricePerOutput,
        requiredBuyPrices
      };
    }

    function displayResults() {
      const container = document.getElementById("results");
      container.innerHTML = "";

      recipes.forEach(recipe => {
        const current = calculateProfit(recipe, "latest");
        const div = document.createElement("div");
        div.className = "profit";
        div.innerHTML = `
          <h3>${recipe.name}</h3>
          <p><strong>Current Profit:</strong> <span class="${current.profit >= 0 ? 'positive' : 'negative'}">${current.profit.toLocaleString()} gp</span></p>
          <p><strong>To achieve this profit, you must:</strong></p>
          <ul>
            <li>Sell <strong>${recipe.output.item}</strong> for at least <strong>${current.requiredSellPrice.toLocaleString()} gp</strong></li>
            ${current.requiredBuyPrices.map(b => `<li>Buy <strong>${b.item}</strong> at or below <strong>${b.price.toLocaleString()} gp</strong></li>`).join('')}
          </ul>
        `;
        container.appendChild(div);
      });
    }

    function parseCustomRecipe() {
      const lines = document.getElementById("custom-recipe").value.trim().split("\n");
      const inputs = [];
      let output = null;
      for (const line of lines) {
        if (line.includes("=")) {
          const [_, right] = line.split("=");
          const [qty, ...name] = right.trim().split(" ");
          output = { item: name.join(" "), quantity: parseInt(qty) };
        } else {
          const [qty, ...name] = line.trim().split(" ");
          inputs.push({ item: name.join(" "), quantity: parseInt(qty) });
        }
      }
      return { name: "Custom Recipe", inputs, output };
    }

    function addCustomRecipe() {
      const custom = parseCustomRecipe();
      recipes.push(custom);
      displayResults();
    }

    async function refreshData() {
      await fetchData();
      displayResults();
    }

    // Initial load
    refreshData();
  </script>
</body>
</html>
